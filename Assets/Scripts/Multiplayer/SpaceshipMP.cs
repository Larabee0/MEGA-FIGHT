//
// Copyright (c) Brian Hernandez. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
//

using Unity.Netcode;
using UnityEngine;

namespace MultiplayerRunTime
{
    /// <summary>
    /// This is a very demo-ey example of how to interpret the input generated by the
    /// MouseFlightController. The plane flies towards the MouseAimPos automatically in
    /// a similar fashion to how War Thunder's Instructor does it. There are also
    /// keyboard overrides for flight control. It's not perfect, but it works well enough
    /// for an example.
    /// </summary>
    [RequireComponent(typeof(Rigidbody))]
    public class SpaceshipMP : NetworkBehaviour
    {
        [Header("Local Components")]
        public Transform FPSCamPos;
        public Transform TargetPoint;
        public Transform[] WeaponOutputPoints;
        public LaserSpawnerMP laserSpawnerMP;
        public ShipHealthManagerMP shipHealthManagerMP;

        public Vector3 AimOffset { get => FPSCamPos != null ? new Vector3(0f, FPSCamPos.localPosition.y) : Vector3.zero; }

        private float TargetDistance
        {
            set
            {
                TargetPoint.localPosition = new(TargetPoint.localPosition.x, TargetPoint.localPosition.y, value);
            }
        }

        [Header("Physics")]
        [Tooltip("Force to push plane forwards with")] public float thrust = 100f;
        [Tooltip("Pitch, Yaw, Roll")] public Vector3 turnTorque = new(90f, 25f, 45f);
        [Tooltip("Multiplier for all forces")] public float forceMult = 1000f;

        [Header("Autopilot")]
        [Tooltip("Sensitivity for autopilot flight.")] public float sensitivity = 5f;
        [Tooltip("Angle at which airplane banks fully into target.")] public float aggressiveTurnAngle = 10f;

        [Header("Server Input")]
        private NetworkVariable<float> throttle = new();
        public float Throttle { set { value = Mathf.Clamp(value, -0.25f, 1f); SetThrottleServerRPC(value); Drag = value; } get { return throttle.Value; } }

        private float Drag { set { rigid.drag = value == 0 ? 2.5f : Mathf.Clamp(Mathf.Lerp(1f, 5f, Mathf.Abs(value)*1.2f), 1f, 5f); } }

        private Vector3 playerOverride ;
        public Vector3 MouseAimPos;

        private Rigidbody rigid;

        private float pitch = 0f;
        private float yaw = 0f;
        private float roll = 0f;
        private bool rollOverride = false;
        private bool yawOverride = false;
        private bool pitchOverride = false;
        private void Awake()
        {
            rigid = GetComponent<Rigidbody>();
        }

        private void Update()
        {
            if (IsServer)
            {

                rollOverride = false;
                pitchOverride = false;
                yawOverride = false;
                // roll (z)
                if (Mathf.Abs(playerOverride.x) > .25f)
                {
                    rollOverride = true;
                }
                // pitch (x)
                if (Mathf.Abs(playerOverride.y) > .25f)
                {
                    yawOverride = true;
                    pitchOverride = true;
                    rollOverride = true;
                }
                // yaw (y)
                if (Mathf.Abs(playerOverride.z) > .25f)
                {
                    yawOverride = true;
                    pitchOverride = true;
                    rollOverride = true;
                }

                RunAutopilot(MouseAimPos, out float autoYaw, out float autoPitch, out float autoRoll);
                yaw = yawOverride ? playerOverride.z : autoYaw;
                pitch = pitchOverride ? playerOverride.y : autoPitch;
                roll = rollOverride ? playerOverride.x : autoRoll;
            }
        }

        private void FixedUpdate()
        {
            if (IsServer)
            {
                // Ultra simple flight where the plane just gets pushed forward and manipulated
                // with torques to turn.
                rigid.AddRelativeForce(forceMult * Throttle * thrust * Vector3.forward, ForceMode.Force);
                //rigid.AddRelativeTorque(TorqueInput, ForceMode.Force);
                rigid.AddRelativeTorque(forceMult * new Vector3(turnTorque.x * pitch, turnTorque.y * yaw, -turnTorque.z * roll), ForceMode.Force);
            }
        }

        private void RunAutopilot(Vector3 flyTarget, out float yaw, out float pitch, out float roll)
        {
            Vector3 localFlyTarget = transform.InverseTransformPoint(flyTarget).normalized * sensitivity;
            float angleOffTarget = Vector3.Angle(transform.forward, flyTarget - transform.position);

            yaw = Mathf.Clamp(localFlyTarget.x, -1f, 1f);
            pitch = -Mathf.Clamp(localFlyTarget.y, -1f, 1f);

            float agressiveRoll = Mathf.Clamp(localFlyTarget.x, -1f, 1f);

            float wingsLevelRoll = transform.right.y;

            float wingsLevelInfluence = Mathf.InverseLerp(0f, aggressiveTurnAngle, angleOffTarget);
            roll = Mathf.Lerp(wingsLevelRoll, agressiveRoll, wingsLevelInfluence);
        }


        [ServerRpc(Delivery = RpcDelivery.Unreliable, RequireOwnership = true)]
        public void SetThrottleServerRPC(float throttle)
        {
            this.throttle.Value = throttle;
        }

        [ServerRpc(Delivery = RpcDelivery.Unreliable, RequireOwnership = true)]
        public void SetTargetposServerRPC(Vector3 pos)
        {
            TargetPoint.localPosition = pos;
        }

        [ServerRpc(Delivery = RpcDelivery.Unreliable, RequireOwnership = true)]
        public void SetTargetDstServerRPC(float dst)
        {
            TargetDistance = dst;
        }

        [ServerRpc(Delivery = RpcDelivery.Unreliable, RequireOwnership = true)]
        public void SetPlayerOverrideServerRPC(Vector3 pos)
        {
            playerOverride = pos;
        }

        [ServerRpc(Delivery = RpcDelivery.Unreliable, RequireOwnership = true)]
        public void SetMouseAimPosServerRPC(Vector3 pos)
        {
            MouseAimPos = pos;
        }


    }
}
