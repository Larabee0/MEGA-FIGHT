//
// Copyright (c) Brian Hernandez. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
//

using Unity.Netcode;
using UnityEngine;

namespace MultiplayerRunTime
{
    /// <summary>
    /// This is a very demo-ey example of how to interpret the input generated by the
    /// MouseFlightController. The plane flies towards the MouseAimPos automatically in
    /// a similar fashion to how War Thunder's Instructor does it. There are also
    /// keyboard overrides for flight control. It's not perfect, but it works well enough
    /// for an example.
    /// </summary>
    [RequireComponent(typeof(Rigidbody))]
    public class SpaceshipMP : NetworkBehaviour
    {
        [Header("Physics")]
        [Tooltip("Force to push plane forwards with")] public float thrust = 100f;
        [Tooltip("Pitch, Yaw, Roll")] public Vector3 turnTorque = new(90f, 25f, 45f);
        [Tooltip("Multiplier for all forces")] public float forceMult = 1000f;

        [Header("Autopilot")]
        [Tooltip("Sensitivity for autopilot flight.")] public float sensitivity = 5f;
        [Tooltip("Angle at which airplane banks fully into target.")] public float aggressiveTurnAngle = 10f;

        [Header("Server Input")]
        [SerializeField] private NetworkVariable<float> throttle = new(NetworkVariableReadPermission.OwnerOnly);

        public float Throttle { set { value = Mathf.Clamp(value, -0.25f, 1f); SetThrottleServerRPC(value); Drag = value; } get { return throttle.Value; } }

        private float Drag { set { rigid.drag = Mathf.Clamp(Mathf.Lerp(1f, 5f, Mathf.Abs(value)*1.2f), 1f, 5f); } }

        private Vector3 torqueInput;

        public Vector3 TorqueInput { set { SetTorqueInputServerRPC(value); torqueInput = value; } get => torqueInput; }

        private Rigidbody rigid;

        private void Awake()
        {
            rigid = GetComponent<Rigidbody>();
        }

        [ServerRpc(Delivery = RpcDelivery.Unreliable, RequireOwnership = true)]
        public void SetThrottleServerRPC(float throttle)
        {
            this.throttle.Value = throttle;
        }

        [ServerRpc(Delivery = RpcDelivery.Unreliable, RequireOwnership = true)]
        public void SetTorqueInputServerRPC(Vector3 torques)
        {
            torqueInput = torques;
        }

        private void FixedUpdate()
        {
            // Ultra simple flight where the plane just gets pushed forward and manipulated
            // with torques to turn.
            rigid.AddRelativeForce(forceMult * Throttle * thrust * Vector3.forward, ForceMode.Force);
            rigid.AddRelativeTorque(TorqueInput, ForceMode.Force);
        }
    }
}
