//
// Copyright (c) Brian Hernandez. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
//

using Unity.Netcode;
using UnityEngine;

namespace MultiplayerRunTime
{
    /// <summary>
    /// This is a very demo-ey example of how to interpret the input generated by the
    /// MouseFlightController. The plane flies towards the MouseAimPos automatically in
    /// a similar fashion to how War Thunder's Instructor does it. There are also
    /// keyboard overrides for flight control. It's not perfect, but it works well enough
    /// for an example.
    /// </summary>
    [RequireComponent(typeof(Rigidbody))]
    public class SpaceshipMP : NetworkBehaviour
    {
        const float k_NullInput = 0.01f;
        [Header("Local Components")]
        public Vector3 TPSCameraPosition = new(0, 9, -35.2f);
        public Transform FPSCamPos;
        public Transform TargetPoint;
        public ShipPartMP[] WeaponOutputPoints;
        public LaserSpawnerMP laserSpawnerMP;
        public ShipHealthManagerMP shipHealthManagerMP;
        public delegate void ShipDestroyed();

        public ShipDestroyed OnShipDestroyed;

        public Vector3 AimOffset { get => FPSCamPos != null ? new Vector3(0f, FPSCamPos.localPosition.y) : Vector3.zero; }

        public float TargetDistance
        {
            set
            {
                TargetPoint.localPosition = new(TargetPoint.localPosition.x, TargetPoint.localPosition.y, value);
            }
        }

        [Header("Physics")]
        [Tooltip("Force to push plane forwards with")] public float thrust = 100f;
        [Tooltip("Pitch, Yaw, Roll")] public Vector3 turnTorque = new(90f, 25f, 45f);
        [Tooltip("Multiplier for all forces")] public float forceMult = 1000f;

        [Header("Autopilot")]
        [Tooltip("Sensitivity for autopilot flight.")] public float sensitivity = 5f;
        [Tooltip("Angle at which airplane banks fully into target.")] public float aggressiveTurnAngle = 10f;

        [Header("Client Authroative Input")]
        private float throttle = 0f;
        public float Throttle { set { throttle = Mathf.Clamp(value, -0.25f, 1f); } get { return throttle; } }

        private float Drag { set { rigid.drag = value == 0 ? 2.5f : Mathf.Clamp(Mathf.Lerp(1f, 5f, Mathf.Abs(value) * 1.2f), 1f, 5f); } }

        public Vector3 controlInput;

        private Rigidbody rigid;

        public bool Kinematic
        {
            set => rigid.isKinematic = value;
        }

        public float Velocity
        {
            get => rigid.velocity.magnitude;
        }

        private void Awake()
        {
            rigid = GetComponent<Rigidbody>();
        }

        private void FixedUpdate()
        {
            switch (IsOwner)
            {
                case true:
                    // Ultra simple flight where the plane just gets pushed forward and manipulated
                    // with torques to turn.
                    rigid.AddRelativeForce(forceMult * Throttle * thrust * shipHealthManagerMP.ThrustEfficiency * Vector3.forward, ForceMode.Force);
                    
                    rigid.AddRelativeTorque(shipHealthManagerMP.ManeourveEfficiency * forceMult * new Vector3(turnTorque.x * controlInput.y, turnTorque.y * controlInput.z, -turnTorque.z * controlInput.x), ForceMode.Force);                    
                    break;
            }
        }

        public override void OnNetworkDespawn()
        {
            base.OnNetworkDespawn();
            switch (IsOwner||IsServer)
            {
                case true:
                    OnShipDestroyed?.Invoke();
                    break;
            }
        }
    }
}
