//
// Copyright (c) Brian Hernandez. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
//

using System.Collections.Generic;
using Unity.Netcode;
using UnityEngine;

namespace MultiplayerRunTime
{
    /// <summary>
    /// This is a very demo-ey example of how to interpret the input generated by the
    /// MouseFlightController. The plane flies towards the MouseAimPos automatically in
    /// a similar fashion to how War Thunder's Instructor does it. There are also
    /// keyboard overrides for flight control. It's not perfect, but it works well enough
    /// for an example.
    /// </summary>
    [RequireComponent(typeof(Rigidbody))]
    public class SpaceshipMP : NetworkBehaviour
    {
        const float minImpactVelocity = 30f;
        const float maxImpactVelocity = 350f;
        const float minImpactDamage = 1f;
        const float maxImpactDamage = 200f;
        [Header("Local Components")]
        public Vector3 TPSCameraPosition = new(0, 9, -35.2f);
        public Transform FPSCamPos;
        public Transform TargetPoint;
        public ShipPartMP[] WeaponOutputPoints;
        public LaserSpawnerMP laserSpawnerMP;
        public ShipHealthManagerMP shipHealthManagerMP;
        public delegate void ShipDestroyed();

        public ShipDestroyed OnShipDestroyed;

        public Vector3 AimOffset { get => FPSCamPos != null ? new Vector3(0f, FPSCamPos.localPosition.y) : Vector3.zero; }

        //public float TargetDistance
        //{
        //    set
        //    {
        //        TargetPoint.localPosition = new(TargetPoint.localPosition.x, TargetPoint.localPosition.y, value);
        //    }
        //}

        [Header("Physics")]
        [Tooltip("Force to push plane forwards with")] public float thrust = 100f;
        [Tooltip("Pitch, Yaw, Roll")] public Vector3 turnTorque = new(90f, 25f, 45f);
        [Tooltip("Multiplier for all forces")] public float forceMult = 1000f;

        [Header("Autopilot")]
        [Tooltip("Sensitivity for autopilot flight.")] public float sensitivity = 5f;
        [Tooltip("Angle at which airplane banks fully into target.")] public float aggressiveTurnAngle = 10f;

        [Header("Client Authroative Input")]
        private float throttle = 0f;
        public float Throttle { set { throttle = Mathf.Clamp(value, -0.25f, 1f); } get { return throttle; } }

        private float Drag { set { rigid.drag = value == 0 ? 2.5f : Mathf.Clamp(Mathf.Lerp(1f, 5f, Mathf.Abs(value) * 1.2f), 1f, 5f); } }

        public Vector3 controlInput;

        private Rigidbody rigid;

        public bool Kinematic
        {
            set => rigid.isKinematic = value;
        }

        public float Velocity
        {
            get => rigid.velocity.magnitude;
        }

        private void Awake()
        {
            rigid = GetComponent<Rigidbody>();
        }

        private void FixedUpdate()
        {
            switch (IsOwner)
            {
                case true:
                    // Ultra simple flight where the plane just gets pushed forward and manipulated
                    // with torques to turn.
                    rigid.AddRelativeForce(forceMult * Throttle * thrust * shipHealthManagerMP.ThrustEfficiency * Vector3.forward, ForceMode.Force);
                    
                    rigid.AddRelativeTorque(shipHealthManagerMP.ManeourveEfficiency * forceMult * new Vector3(turnTorque.x * controlInput.y, turnTorque.y * controlInput.z, -turnTorque.z * controlInput.x), ForceMode.Force);                    
                    break;
            }
        }

        private void OnCollisionEnter(Collision collision)
        {
            switch (IsOwner)
            {
                case false:

                    return;
            }
            float relativeVelocity = collision.relativeVelocity.magnitude;

            float damage = Mathf.Lerp(minImpactDamage, maxImpactDamage, Mathf.InverseLerp(minImpactVelocity, maxImpactVelocity, relativeVelocity));

            if(relativeVelocity < minImpactVelocity)
            {
                return;
            }
            ContactPoint[] contacts = collision.contacts;
            HashSet<InternalCollisionHandler> unquieParts = new HashSet<InternalCollisionHandler>();
            for (int i = 0; i < contacts.Length; i++)
            {
                ContactPoint point = contacts[i];
                if(point.thisCollider.gameObject.TryGetComponent(out ShipPartMP part1))
                {
                    unquieParts.Add(new(part1));
                }
                if (point.otherCollider.gameObject.TryGetComponent(out ShipPartMP part2))
                {
                    unquieParts.Add(new(part2));
                }
            }

            InternalCollisionHandler[] unquieCollisions = new InternalCollisionHandler[unquieParts.Count];
            unquieParts.CopyTo(unquieCollisions);

            for (int i = 0; i < unquieCollisions.Length; i++)
            {
                InternalCollisionHandler part = unquieCollisions[i];
                if(part.owner == OwnerClientId)
                {
                    Debug.LogFormat("Part ID {0} hit at {1}m/s, takes {2} damage", part.HierarchyID, relativeVelocity, damage);
                    shipHealthManagerMP.HitServerRpc(part.HierarchyID, OwnerClientId, damage);
                }
            }
        }

        private struct InternalCollisionHandler
        {
            public ulong owner;
            public byte HierarchyID;
            public InternalCollisionHandler(ShipPartMP part)
            {
                owner = part.OwnerClientId;
                HierarchyID = part.HierarchyID;
            }
        }


        public override void OnNetworkDespawn()
        {
            base.OnNetworkDespawn();
            switch (IsOwner||IsServer)
            {
                case true:
                    OnShipDestroyed?.Invoke();
                    break;
            }
        }
    }
}
